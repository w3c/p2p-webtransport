<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8">
  <link href="webrtc.css" rel="stylesheet">
  <title>QUIC API for WebRTC</title>
  <script class="remove" src="respec-w3c-common.js" type="text/javascript"></script>
  <script src="respec-config.js" class="remove"></script>
</head>
<body>
  <section id="abstract">
    <p>This document defines a set of ECMAScript APIs in WebIDL to allow data to be sent
    and received from another browser or device implementing the QUIC
    protocol. This specification is being developed in conjunction with a protocol
    specification developed by the IETF QUIC Working Group.</p>
  </section>
  <section id="sotd">
    <p>The API is based on preliminary work done in the W3C ORTC Community Group.</p>
  </section>
  <section class="informative" id="intro">
    <h2>Introduction</h2>
    <p>This specification extends the WebRTC specification [[!WEBRTC]] to
    enable the use of QUIC [[!QUIC-TRANSPORT]] to exchange arbitrary data with
    remote peers using NAT-traversal technologies such as ICE, STUN, and
    TURN. Since QUIC can be multiplexed on the same port as RTP, RTCP,
    DTLS, STUN and TURN, this specification is compatible with all the
    functionality defined in [[!WEBRTC]], including communication
    using audio/video media and SCTP data channels.</p>
    <p>While this specification defines an interface to QUIC streams,
    by utilizing a QUIC stream per message, it is possible to implement
    support for message-based communications (such as <code>RTCDataChannel</code>)
    on top.  While the QUIC transport defined in [[!QUIC-TRANSPORT]] is reliable,
    support for unreliable communications is achievable via use of timers or
    through extensions to the QUIC protocol.</p>
  </section>
  <section id="conformance">
    <p>This specification defines conformance criteria that apply to a single
    product: the <dfn>user agent</dfn> that implements the interfaces that it
    contains.</p>
    <p>Conformance requirements phrased as algorithms or specific steps may be
    implemented in any manner, so long as the end result is equivalent. (In
    particular, the algorithms defined in this specification are intended to be
    easy to follow, and not intended to be performant.)</p>
    <p>Implementations that use ECMAScript to implement the APIs defined in
    this specification MUST implement them in a manner consistent with the
    ECMAScript Bindings defined in the Web IDL specification [[!WEBIDL-1]], as
    this specification uses that specification and terminology.</p>
  </section>
  <section>
    <h2>Terminology</h2>
     <p>The <code><a href=
      "http://dev.w3.org/html5/spec/webappapis.html#eventhandler">EventHandler</a></code>
      interface, representing a callback used for event handlers, and the <a href=
      "http://dev.w3.org/html5/spec/webappapis.html#errorevent"><code><dfn>ErrorEvent</dfn></code></a>
      interface are defined in [[!HTML51]].</p>
      <p>The concepts <dfn><a href=
      "http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">queue a task</a></dfn>,
      <dfn><a href=
      "http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fires a simple
      event</a></dfn> and <dfn><a href=
      "http://dev.w3.org/html5/spec/webappapis.html#networking-task-source">networking
      task source</a></dfn> are defined in [[!HTML51]].</p>
      <p>The term <dfn>finished reading</dfn> means that the application has read all
      available data up to the STREAM frame with the FIN bit set, which causes
      the <a>[[\Readable]]</a> slot to be set to <code>false</code>.</p> 
      <p>The terms <dfn>event</dfn>, <dfn><a href=
      "http://dev.w3.org/html5/spec/webappapis.html#event-handlers">event
      handlers</a></dfn> and <dfn><a href=
      "http://dev.w3.org/html5/spec/webappapis.html#event-handler-event-type">event
      handler event types</a></dfn> are defined in [[!HTML51]].</p>
     <p>When referring to exceptions, the terms <dfn><a
      href="https://www.w3.org/TR/WebIDL-1/#dfn-throw">throw</a></dfn> and
      <dfn data-dfn-for="exception"><a href=
      "https://www.w3.org/TR/WebIDL-1/#dfn-create-exception">create</a></dfn> are
      defined in [[!WEBIDL-1]].</p>
      <p>The terms <dfn data-lt="fulfill|fulfillment">fulfilled</dfn>, <dfn
      data-lt="reject|rejection|rejecting|rejected">rejected</dfn>,
      <dfn data-lt="resolve|resolves">resolved</dfn>, <dfn>pending</dfn> and
      <dfn data-lt="settled">settled</dfn> used in the context of Promises are defined in
      [[!ECMASCRIPT-6.0]].</p>
      <p>The <dfn><code>RTCIceTransport</code></dfn> and <dfn><code>RTCCertificate</code></dfn> interfaces
      and the <dfn><code>RTCDtlsFingerprint</code></dfn> dictionary are defined in [[!WEBRTC]].</p>
  </section>
  <section id="quic-transport*">
    <h2><dfn>RTCQuicTransport</dfn> Interface</h2>
    <p>The <code>RTCQuicTransport</code> includes information relating
    to QUIC transport.</p>
    <section id="rtcquictransport-overview*">
      <h3>Overview</h3>
      <p>An <code><a>RTCQuicTransport</a></code> instance is associated to
      one or more <code><a>RTCQuicStream</a></code> instances.</p>
      <p class="note">The QUIC API presented in this and the subsequent
      section represents a preliminary proposal based on work-in-progress
      within the IETF QUIC WG. Since the QUIC protocol specification is still
      in its early stages, both the protocol and API are likely to
      change significantly going forward (such as changes to support
      uni-directional streams).</p>
    </section>
    <section id="rtcquictransport-operation*">
      <h3>Operation</h3>
      <p>The QUIC transport protocol is described in [[!QUIC-TRANSPORT]].
      A <code><a>RTCQuicTransport</a></code> instance is constructed
      using an <code><a>RTCIceTransport</a></code> and a sequence of
      <code><a>RTCCertificate</a></code> objects.
      An <code><a>RTCQuicTransport</a></code> object in the <code>closed</code> or
      <code>failed</code> states can be garbage-collected when it is no longer
      referenced.</p>
      <p>The QUIC negotiation occurs between transport endpoints determined via ICE.
      Approaches to multiplexing of QUIC with STUN, TURN, DTLS, RTP and RTCP
      are described in [[QUIC-MULT]].</p>
      <p>A newly constructed <code><a>RTCQuicTransport</a></code> <em class="rfc2119"
      title="MUST">MUST</em> listen and respond to incoming QUIC packets before
      <code>start()</code> is called. However, to complete the negotiation it is
      necessary to verify the remote fingerprint by computing fingerprints for
      the selected remote certificate using the digest algorithms provided
      in <code><var>remoteParameters</var>.fingerprints[].algorithm</code>. If a
      calculated fingerprint and algorithm matches a fingerprint and algorithm
      included in <code><var>remoteParameters</var>.fingerprints[]</code>,
      the remote fingerprint is verified. After the QUIC handshake exchange
      completes (but before the remote fingerprint is verified) incoming media packets
      may be received. A modest buffer <em class="rfc2119" title="MUST">MUST</em> be
      provided to avoid loss of media prior to remote fingerprint validation (which can
      begin after <code>start()</code> is called).</p>
    </section>
    <section id="rtcquictransport-interface-definition*">
      <h3>Interface Definition</h3>
      <div>
        <pre class="idl">
        [ Constructor (RTCIceTransport transport, optional sequence&lt;RTCCertificate&gt; certificates), Exposed=Window]
interface RTCQuicTransport : RTCStatsProvider {
    readonly        attribute RTCIceTransport          transport;
    readonly        attribute RTCQuicTransportState    state;
    RTCQuicParameters     getLocalParameters ();
    RTCQuicParameters?    getRemoteParameters ();
    sequence&lt;RTCCertificate&gt; getCertificates ();
    sequence&lt;ArrayBuffer&gt; getRemoteCertificates ();
    void                  start (RTCQuicParameters remoteParameters);
    void                  stop ();
    RTCQuicStream         createStream ();
                    attribute EventHandler             onstatechange;
                    attribute EventHandler             onerror;
                    attribute EventHandler             onquicstream;
};</pre>
        <section>
          <h2>Constructors</h2>
          When the <code><a>RTCQuicTransport</a></code> constructor is invoked,
          the user agent MUST run the following steps:
          <ol>
            <li>If the <code><a>RTCIceTransport</a></code> <var>transport</var>
            provided in the first argument is in the <code>closed</code>
            state, <a>throw</a> an <code>InvalidStateError</code> and abort
            these steps.</li>
            <li>If <var>transport</var> has been used to construct another
            <code><a>RTCQuicTransport</a></code> whose <a>[[\QuicTransportState]]</a> slot
            is not <code>"closed"</code>, <a>throw</a> an <code>InvalidStateError</code>
            and abort these steps.</li>
            <li>If the <code>certificates</code> argument is provided and is non-empty, check that the
            <code>expires</code> attribute of each <code><a>RTCCertificate</a></code> object
            is in the future. If a certificate has expired, <a>throw</a> an <code>InvalidAccessError</code>.</li>
            <li>Let <var>quictransport</var> be a newly constructed <code><a>RTCQuicTransport</a></code> object.</li>
            <li>Let <var>quictransport</var> have a <dfn>[[\QuicTransportState]]</dfn> internal slot, initialized to
            <code>"new"</code>.</li>
            <li>Let <var>quictransport</var> have a <dfn>[[\Certificates]]</dfn> internal slot.</li>
            <li>If the <code>certificates</code> argument is provided and is non-empty,
            initialize the <a>[[\Certificates]]</a> internal slot to the
            the <var>certificates</var> argument passed in the constructor.</li>
            <li>If the <code>certificates</code> argument is not provided or is empty,
            generate a certificate using the default ciphersuite and store this in the
            the <a>[[\Certificates]]</a> internal slot.</li>  
            <li>Return <var>quictransport</var>.</li>
          </ol>          
          <dl data-link-for="RTCQuicTransport" data-dfn-for="RTCQuicTransport" class=
          "constructors">
            <dt><code><a>RTCQuicTransport</a></code></dt>
            <dd>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">transport</td>
                    <td class="prmType"><code><a>RTCIceTransport</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">certificates</td>
                    <td class="prmType">
                    <code>sequence</code>&lt;<code><a>RTCCertificate</a></code>&gt;</td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCQuicTransport" data-dfn-for="RTCQuicTransport" class=
          "attributes">
            <dt><dfn><code>transport</code></dfn> of type <span class=
            "idlAttrType"><a>RTCIceTransport</a></span>, readonly</dt>
            <dd>
              <p>The associated <code><a>RTCIceTransport</a></code> instance.</p>
            </dd>
            <dt><dfn><code>state</code></dfn> of type <span class=
            "idlAttrType"><a>RTCQuicTransportState</a></span>, readonly</dt>
            <dd>
              <p>The current state of the QUIC transport. On getting, it MUST return
              the value of the <a>[[\QuicTransportState]]</a> internal slot.</p>
            </dd>
            <dt><dfn><code>onstatechange</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              <p>This event handler, of event handler event type
              <code><a>statechange</a></code>, <em class="rfc2119" title="MUST">MUST</em>
              be fired any time the <a>[[\QuicTransportState]]</a> slot changes.</p>
            </dd>
            <dt><dfn><code>onerror</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              <p>This event handler, of event handler event type <code>error</code>,
              <em class="rfc2119" title="MUST">MUST</em> be fired on reception of a QUIC
              error; an implementation <em class="rfc2119" title=
              "SHOULD">SHOULD</em> include QUIC error information in
              <var>error.message</var> (defined in [[!HTML51]] Section 7.1.3.8.2).</p>
            </dd>
            <dt><dfn><code>onquicstream</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              <p>This event handler, of event handler event type <code><a>quicstream</a></code>,
              <em class="rfc2119" title="MUST">MUST</em> be fired on when a remote
              <code><a>RTCQuicStream</a></code> is created.</p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCQuicTransport" data-dfn-for="RTCQuicTransport" class=
          "methods">
            <dt><code>getLocalParameters</code></dt>
            <dd>
              <p><dfn>getLocalParameters()</dfn> obtains the QUIC parameters of
              the local <code><a>RTCQuicTransport</a></code> upon construction.
              If multiple certificates were provided in the constructor, then
              multiple fingerprints will be returned, one for each certificate.
              <code>getLocalParameters().role</code> always returns the default
              role of a newly constructed <code><a>RTCQuicTransport</a></code>;
              for a browser this will be <code>auto</code>.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code><a>RTCQuicParameters</a></code>
              </div>
            </dd>
            <dt><code>getRemoteParameters</code></dt>
            <dd>
              <p><dfn>getRemoteParameters()</dfn> obtains
              the remote QUIC parameters passed in the
              <code>start()</code> method. Prior to calling
              <code>start()</code>, null is returned.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code><a>RTCQuicParameters</a></code>, nullable
              </div>
            </dd>
            <dt><code>getCertificates</code></dt>
            <dd>
              <p><dfn>getCertificates()</dfn> returns the value of the <code><a>RTCQuicTransport</a></code>'s
              <a>[[\Certificates]]></a> internal slot.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>sequence&lt;RTCCertificate&gt;</code>
              </div>
            </dd>
            <dt><code>getRemoteCertificates</code></dt>
            <dd>
              <p><dfn>getRemoteCertificates()</dfn> returns the certificate chain in use by the remote side, with each
              certificate encoded in binary Distinguished Encoding Rules (DER) [[!X690]].
              <code><a>getRemoteCertificates()</a></code> returns an empty list prior to
              selection of the remote certificate, which is completed once
              <code><a>RTCQuicTransportState</a></code> transitions to
              <code>connected</code>.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>sequence&lt;ArrayBuffer&gt;</code>
              </div>
            </dd>
            <dt><dfn><code>start</code></dfn></dt>
            <dd>
              <p>Start QUIC transport negotiation with the parameters of the remote QUIC
              transport, including verification of the remote fingerprint.
              Only a single QUIC transport can be multiplexed over an ICE transport.
              Therefore if a <code><a>RTCQuicTransport</a></code> object
              <var>quicTransportB</var> is constructed with an
              <code><a>RTCIceTransport</a></code> object <var>iceTransport</var>
              previously used to construct another <code><a>RTCQuicTransport</a></code>
              object <var>quicTransportA</var>, then if
              <code>quicTransportB.start()</code> is called prior to having called
              <code>quicTransportA.stop()</code>, then <a>throw</a> an
              <code>InvalidStateError</code>.</p>
              <p>If <code>start</code> is called after a previous <code>start</code>
              call, or if <code>state</code> is <code>closed</code>, <a>throw</a>
              an <code>InvalidStateError</code>.</p>
              <p>If all of the values of
              <code><var>remoteParameters</var>.fingerprints[<var>j</var>].algorithm</code>
              are unsupported, where <var>j</var> goes from 0 to the number of fingerprints,
              <a>throw</a> a <code>NotSupportedError</code>.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">remoteParameters</td>
                    <td class="prmType"><code><a>RTCQuicParameters</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt><dfn><code>stop</code></dfn></dt>
            <dd>
              <p>Stops and closes the <code><a>RTCQuicTransport</a></code> object.
              Calling <code>stop()</code> when <code>state</code> is <code>closed</code>
              has no effect.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
           <dt><dfn><code>createStream</code></dfn></dt>
            <dd>
              <p>Creates an <code><a>RTCQuicStream</a></code> object.
              Since [[QUIC-TRANSPORT]] only defines reliable QUIC streams,
              <code>createStream</code> only supports creation of reliable
              streams.</p>
              <p>When <code>createStream</code> is called, the user agent MUST run the
              following steps:</p>
              <ol>
                <li>Let <var>transport</var> be the <code><a>RTCQuicTransport</a></code>
                on which <code>createStream</code> is invoked.</li>
                <li>If <code><var>transport</var>.state</code> is <code>closed</code>
                <a>throw</a> an <code>InvalidStateError</code>.</li>
               <li>
                  <p>Let <var>stream</var> be a newly created
                  <code><a>RTCQuicStream</a></code> object.</p>
                </li>
                <li>
                  <p>Let <var>stream</var> have a <dfn>[[\QuicStreamState]]</dfn> internal
                  slot initialized to <code>new</code>.</p>
                </li>
                <li>
                  <p>Let <var>stream</var> have a <dfn>[[\Readable]]</dfn> internal
                  slot initialized to <code>false</code>.</p>
                </li>
                <li>
                  <p>Let <var>stream</var> have a <dfn>[[\Writable]]</dfn> internal
                  slot initialized to <code>false</code>.</p>
                </li>
                <li>
                  <p>Let <var>stream</var> have a <dfn>[[\QueuedAmount]]</dfn> internal
                  slot initialized to zero.</p>
                </li>
                <li>
                  <p>Let <var>stream</var> have a <dfn>[[\ReadableAmount]]</dfn> internal
                  slot initialized to zero.</p>
                </li>
                <li>
                  <p>Return <var>stream</var> and continue the following steps
                  in the background.</p>
                </li>
                <li>
                  <p>Create <var>stream</var>'s associated underlying data
                  transport.</p>
                </li>
              </ol>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code><a>RTCQuicStream</a></code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="rtcquicparameters*">
      <h3><dfn>RTCQuicParameters</dfn> Dictionary</h3>
      <p>The <code>RTCQuicParameters</code> dictionary includes information
      relating to QUIC configuration.</p>
      <div>
        <pre class="idl">dictionary RTCQuicParameters {
             RTCQuicRole                  role = "auto";
             sequence&lt;RTCDtlsFingerprint&gt; fingerprints;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCQuicParameters</a> Members</h2>
          <dl data-link-for="RTCQuicParameters" data-dfn-for="RTCQuicParameters" class=
          "dictionary-members">
            <dt><dfn><code>role</code></dfn> of type <span class=
            "idlMemberType"><a>RTCQuicRole</a></span>, defaulting to
            <code>"auto"</code></dt>
            <dd>
              <p>The QUIC role, with a default of <code>auto</code>.</p>
            </dd>
            <dt><dfn><code>fingerprints</code></dfn> of type <span class=
            "idlMemberType">sequence&lt;<a>RTCDtlsFingerprint</a>&gt;</span></dt>
            <dd>
              <p>Sequence of fingerprints, at least one fingerprint for each certificate
              (with one computed with the digest algorithm used in the certificate
              signature).</p>
            </dd> 
          </dl>
        </section>
      </div>
    </section>
    <section>
      <h3><dfn>RTCQuicStreamEvent</dfn></h3>
      <p>The <code><a>quicstream</a></code> event uses the
      <code><a>RTCQuicStreamEvent</a></code> interface.</p>
      <p>Firing a <code><a>quicstream</a></code> event named <var>e</var> with a
      <code><a>RTCQuicStream</a></code> <var>stream</var> means that an event with the
      name <var>e</var>, which does not bubble (except where otherwise stated) and is not
      cancelable (except where otherwise stated), and which uses the
      <code><a>RTCQuicStreamEvent</a></code> interface with the <code>stream</code>
      attribute set to <var>stream</var>, MUST be created and dispatched at the given target.</p>
      <div>
        <pre class="idl">
        [ Constructor (DOMString type, RTCQuicStreamEventInit eventInitDict), Exposed=Window]
interface RTCQuicStreamEvent : Event {
    readonly        attribute RTCQuicStream stream;
};</pre>
        <section>
          <h2>Constructors</h2>
          <dl data-link-for="RTCQuicStreamEvent" data-dfn-for="RTCQuicStreamEvent"
          class="constructors">
            <dt><code>RTCQuicStreamEvent</code></dt>
            <dd>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">type</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">eventInitDict</td>
                    <td class="prmType"><code><a>RTCQuicStreamEventInit</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCQuicStreamEvent" data-dfn-for="RTCQuicStreamEvent"
          class="attributes">
            <dt><code>stream</code> of type <span class=
            "idlAttrType"><a>RTCQuicStream</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id="dom-quicstreamevent-stream"><code>stream</code></dfn>
              attribute represents the <code><a>RTCQuicStream</a></code> object
              associated with the event.</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
          <p>The <dfn><code>RTCQuicStreamEventInit</code></dfn> dictionary includes
          information on the configuration of the QUIC stream.</p>
        <pre class="idl">dictionary RTCQuicStreamEventInit : EventInit {
             RTCQuicStream stream;
};</pre>
        <section>
          <h2>Dictionary RTCQuicStreamEventInit Members</h2>
          <dl data-link-for="RTCQuicStreamEventInit" data-dfn-for=
          "RTCQuicStreamEventInit" class="dictionary-members">
            <dt><dfn><code>stream</code></dfn> of type <span class=
            "idlMemberType"><a>RTCQuicStream</a></span></dt>
            <dd>
              <p>The <code><a>RTCQuicStream</a></code> object associated with the
              event.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="rtcquicrole*">
      <h3><dfn>RTCQuicRole</dfn> Enum</h3>
      <p><code>RTCQuicRole</code> indicates the role of the QUIC
      transport.</p>
      <div>
        <pre class="idl">enum RTCQuicRole {
    "auto",
    "client",
    "server"
};</pre>
        <table data-link-for="RTCQuicRole" data-dfn-for="RTCQuicRole" class="simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn><code id="idl-def-RTCQuicRole.auto">auto</code></dfn></td>
              <td>
                <p>The QUIC role is determined based on the resolved ICE role:
                the ICE <code>controlled</code> role acts as the QUIC client and
                the ICE <code>controlling</code> role acts as the QUIC server.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id="idl-def-RTCQuicRole.client">client</code></dfn></td>
              <td>
                <p>The QUIC client role.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id="idl-def-RTCQuicRole.server">server</code></dfn></td>
              <td>
                <p>The QUIC server role.</p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
    <section id="rtcquicroleinfo">
      <h3>QUIC role determination</h3>
      <p>To diagnose QUIC role issues, an application may wish to determine
      the desired and actual QUIC role of an <code><a>RTCQuicTransport</a></code>.
      For a browser implementing ORTC, a <code><a>RTCQuicTransport</a></code>
      object assumes a QUIC role of <code>auto</code> upon construction.
      This implies that the QUIC role is determined by the ICE role.  Since
      <code>getLocalParameters().role</code> always returns the role assigned
      to an <code><a>RTCQuicTransport</a></code> object upon construction
      (<code>auto</code> for a browser), the <code>getLocalParameters</code>
      method cannot be used to determine the desired or actual role of an
      <code><a>RTCQuicTransport</a></code>.</p>
      <p>An application can determine the
      desired role of an <code><a>RTCQuicTransport</a></code> from the value of
      <code><var>remoteParameters</var>.role</code> passed to
      <code><a>RTCQuicTransport</a>.start(<var>remoteParameters</var>)</code>.
      If <code><var>remoteParameters</var>.role</code> is <code>server</code>
      then the desired role of the <code><a>RTCQuicTransport</a></code>
      is <code>client</code>. If <code><var>remoteParameters</var>.role</code>
      is <code>client</code> then the desired role of the
      <code><a>RTCQuicTransport</a></code> is <code>server</code>.</p>
      <p>The <code>RTCQuicTransport.transport.onstatechange</code> EventHandler
      can be used to determine whether an <code><a>RTCQuicTransport</a></code>
      transitions to the desired role. When
      <code><a>RTCQuicTransport</a>.transport.state</code> transitions to
      <code>connected</code>, if <code><a>RTCQuicTransport</a>.transport.role</code>
      is <code>controlled</code> then the role of the
      <code><a>RTCQuicTransport</a></code> is <code>client</code>.
      If <code><a>RTCQuicTransport</a>.transport.role</code>
      is <code>controlling</code> then the role of the
      <code><a>RTCQuicTransport</a></code> is <code>server</code>.</p>
    </section>
    <section id="rtcquictransportstate*">
      <h3><dfn>RTCQuicTransportState</dfn> Enum</h3>
      <p><code>RTCQuicTransportState</code> indicates the state of the QUIC
      transport.</p>
      <div>
        <pre class="idl">enum RTCQuicTransportState {
    "new",
    "connecting",
    "connected",
    "closed",
    "failed"
};</pre>
        <table data-link-for="RTCQuicTransportState" data-dfn-for="RTCQuicTransportState"
        class="simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn><code id="idl-def-RTCQuicTransportState.new">new</code></dfn></td>
              <td>
                <p>The <code><a>RTCQuicTransport</a></code> object has been created and
                has not started negotiating yet.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-RTCQuicTransportState.connecting">connecting</code></dfn></td>
              <td>
                <p>QUIC is in the process of negotiating a secure connection and
                verifying the remote fingerprint. Once a secure connection is negotiated
                (but prior to verification of the remote fingerprint, enabled by calling
                <code>start()</code>), incoming data can flow through.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-RTCQuicTransportState.connected">connected</code></dfn></td>
              <td>
                <p>QUIC has completed negotiation of a secure connection and verified the
                remote fingerprint. Outgoing data and media can now flow through.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-RTCQuicTransportState.closed">closed</code></dfn></td>
              <td>
                <p>The QUIC connection has been closed intentionally via a call to
                <code>stop()</code> or receipt of a close_notify alert. Calling
                <code>transport.stop()</code> will also result in a transition to the
                <code>closed</code> state.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-RTCQuicTransportState.failed">failed</code></dfn></td>
              <td>
                <p>The QUIC connection has been closed as the result of an error (such as
                receipt of an error alert or a failure to validate the remote
                fingerprint).</p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
  </section>
  <section id="quicstream*">
    <h2><dfn>RTCQuicStream</dfn> Interface</h2>
    <p>The <code>RTCQuicStream</code> includes information relating
    to a QUIC stream. </p>
    <section id="rtcquicstream-overview*">
      <h3>Overview</h3>
      <p>An <code><a>RTCQuicStream</a></code> instance is associated to
      an <code><a>RTCQuicTransport</a></code> instance.</p>
    </section>
    <section id="rtcquicstream-operation*">
      <h3>Operation</h3>
      <p>An <code><a>RTCQuicStream</a></code> instance is constructed
      using the <code><a>RTCQuicTransport</a>.createStream</code> method.</p>
    </section>
    <section id="rtcquicstream-interface-definition*">
      <h3>Interface Definition</h3>
      <div>
        <pre class="idl">
        [ Exposed=Window ]
interface RTCQuicStream {
    readonly        attribute RTCQuicTransport    transport;
    readonly        attribute RTCQuicStreamState  state;
    readonly        attribute unsigned long       readableAmount;
    readonly        attribute unsigned long       queuedAmount;
    long                  readInto (Uint8Array data);
    void                  write (Uint8Array data);
    void                  finish ();
    void                  reset ();
    Promise&lt;void&gt;   waitForReadable(unsigned long amount);
    Promise&lt;void&gt;   waitForQueuedBelow(unsigned long threshold);
                    attribute EventHandler        onstatechange;
};</pre>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCQuicStream" data-dfn-for="RTCQuicStream" class=
          "attributes">
            <dt><dfn><code>transport</code></dfn> of type <span class=
            "idlAttrType"><a>RTCQuicTransport</a></span>, readonly</dt>
            <dd>
              <p>The readonly attribute referring to the related <code><a>RTCQuicTransport</a></code> object.</p>
            </dd>
            <dt><code>state</code> of type <span class=
            "idlAttrType"><a>RTCQuicStreamState</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id="dom-quicstream-state"><code>state</code></dfn>
              attribute represents the state of the <a>RTCQuicStream</a> object.
              On getting it <em class="rfc2119" title="MUST">MUST</em> return
              the value of the <code><a>RTCQuicStream</a></code>'s
              <a>[[\QuicStreamState]]</a> internal slot.</p>
            </dd>
            <dt><dfn><code>onstatechange</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
             <p>This event handler, of event handler event type
              <code><a>statechange</a></code>, <em class="rfc2119" title="MUST">MUST</em>
              be fired any time the <code><a>RTCQuicStreamState</a></code>
              changes.</p>
            </dd>
            <dt><code>readableAmount</code> of type <span class="idlAttrType"><a>unsigned
            long</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id="dom-quicstream-readableamount"><code>readableAmount</code></dfn>
              attribute represents the number of bytes buffered for access by
              <code>readInto</code> but that, as of the last time the event loop
              started executing a task, had not yet been read. This does not include
              framing overhead incurred by the protocol, or buffers associated with
              the network hardware. On getting, it <em class="rfc2119" title="MUST">MUST</em>
              return the value of the <code><a>RTCQuicStream</a></code>'s
              <a>[[\ReadableAmount]]</a> internal slot.
              If the <code><a>RTCQuicStream</a></code> is in the <code>closed</code> state,
              this attribute's value will only decrease with each call to the
              <code>readInto</code> method (the attribute does not reset to zero once the
              <code><a>RTCQuicStream</a></code> closes).</p>
            </dd>
            <dt><code>queuedAmount</code> of type <span class="idlAttrType"><a>unsigned
            long</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id="dom-quicstream-queuedamount"><code>queuedAmount</code></dfn>
              attribute represents the number of bytes of application data
              that have been queued using <code>write</code> but that, as of the last
              time the event loop started executing a task, had not yet been transmitted
              to the network. This includes any data sent during the execution of the
              current task, regardless of whether the <a>user agent</a> is able to
              transmit text asynchronously with script execution. This does not
              include framing overhead incurred by the protocol, or buffering done
              by the operating system or network hardware. On getting, it
              <em class="rfc2119" title="MUST">MUST</em> return the value of the
              <code><a>RTCQuicStream</a></code>'s <a>[[\QueuedAmount]]</a> internal slot.
              If the <code><a>RTCQuicStream</a></code> is in the <code>closed</code>
              state, this attribute's value will only increase with each call to the
              <code>write</code> method (the attribute does not reset to zero once the
              <code><a>RTCQuicStream</a></code> closes).</p>
            </dd>
          </dl>
       </section>
       <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCQuicStream" data-dfn-for="RTCQuicStream" class=
          "methods">
            <dt><dfn><code>readInto</code></dfn></dt>
            <dd>
              <p>Reads from <code><a>RTCQuicStream</a></code> into the buffer specified
              by the first argument and returns the number of bytes read; a negative
              number indicates end-of-file. If there is no data to be read then
              <code>readInto</code> returns zero. When the <code>readInto</code>
              method is called, the user agent
              <em class="rfc2119" title="MUST">MUST</em> run the following steps:</p>
              <ol>
               <li>Let <var>stream</var> be the <code><a>RTCQuicStream</a></code> object
               on which <code>readInto</code> is invoked.</li>
               <li>If <var>stream</var>'s <a>[[\Readable]]</a> slot is <code>false</code>,
               <a>throw</a> an <code>InvalidStateError</code>, then abort these steps.</li>
               <li>Let <var>data</var> be the first argument.</li>
               <li>If <var>stream</var> has <a>finished reading</a> return
               a negative number, set <var>stream</var>'s <a>[[\Readable]]</a> slot to
               <code>false</code> and abort these steps.</li>
               <li>Transfer data from the read buffer into <var>data</var>.</li>
               <li>Decrease the value of <var>stream</var>'s <a>[[\ReadableAmount]]</a>
               slot by the length of <var>data</var> in bytes.</li>
               <li>Return the length of <var>data</var> in bytes.</li>
              </ol>
              <table class="parameters">
               <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">data</td>
                    <td class="prmType"><code>Uint8Array</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>long</code>
              </div>
            </dd>
            <dt><dfn><code>write</code></dfn></dt>
            <dd>
              <p>When the <code>write</code> method is called, the <a>user agent</a>
              MUST run the following steps:</p>
              <ol>
               <li>Let <var>data</var> be the first argument.</li>
               <li>Let <var>stream</var> be the <code><a>RTCQuicStream</a></code>
               object on which <var>data</var> is to be sent.</li>
               <li>If <var>stream</var>'s <a>[[\Writable]]</a> slot is <code>false</code>,
               <a>throw</a> an <code>InvalidStateError</code> and abort these steps.</li>
               <li>Increase the value of <var>stream</var>'s
               <a>[[\QeueueAmount]]</a> slot by the length of
               <var>data</var> in bytes.</li>
               <li>Queue <var>data</var> for transmission on <var>stream</var>'s
               underlying data transport.
               <div class="note">The actual transmission of data occurs in
               parallel. If sending data leads to a QUIC-level error, the
               application will be notified asynchronously through the
               <code><a>RTCQuicTransport</a></code>'s <code><a>onerror</a></code>
               EventHandler.</div></li>
              </ol>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">data</td>
                    <td class="prmType"><code>Uint8Array</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt><dfn><code>finish</code></dfn></dt>
            <dd>
              <p>Initiates the closing procedure for the
              <code><a>RTCQuicStream</a></code>. It may be called
              regardless of whether the <code><a>RTCQuicStream</a></code> object
              was created by the local or remote peer. When the <code>finish()</code>
              method is called, the user agent <em class="rfc2119" title="MUST">MUST</em>
              run the following steps:</p>
              <ol>
                <li>Let <var>stream</var> be the <code><a>RTCQuicStream</a></code> object
                which is about to be closed.</li>
                <li>If <var>stream</var>'s  <a>[[\QuicStreamState]]</a> is <code>new</code>,
                set <var>stream</var>'s  <a>[[\QuicStreamState]]</a> to <code>closed</code>,
                and abort these steps.</li>
                <li>If <var>stream</var>'s  <a>[[\QuicStreamState]]</a> is <code>closed</code>,
                then abort these steps.</li>
                <li>Set <var>stream</var>'s <a>[[\Writable]]</a> slot to <code>false</code>.</li>
                <li>Set <var>stream</var>'s <a>[[\QuicStreamState]]</a> slot to
                <code>closing</code>.</li>
                <li>If <var>stream</var> has <a>finished reading</a>, set
                <var>stream</var>'s <a>[[\QuicStreamState]]</a> slot to
                <code>closed</code>.</li>
                <li>If the closing procedure has not started yet, start it by sending a STREAM
                frame with the FIN bit set.</li>
              </ol>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt><dfn><code>reset</code></dfn></dt>
            <dd>
              <p>Resets the <code><a>RTCQuicStream</a></code>. It may be called
              regardless of whether the <code><a>RTCQuicStream</a></code> object
              was created by the local or remote peer. When the <code>reset()</code>
              method is called, the user agent <em class="rfc2119" title="MUST">MUST</em>
              run the following steps:</p>
              <ol>
                <li>Let <var>stream</var> be the <code><a>RTCQuicStream</a></code> object
                which is about to be reset.</li>
                <li>If <var>stream</var>'s  <a>[[\QuicStreamState]]</a> is <code>new</code>,
                set <var>stream</var>'s  <a>[[\QuicStreamState]]</a> to <code>closed</code>,
                and abort these steps.</li>
                <li>If <var>stream</var>'s  <a>[[\QuicStreamState]]</a> slot is <code>closed</code>,
                then abort these steps.</li>
                <li>Set <var>stream</var>'s <a>[[\Writable]]</a> and <a>[[\Readable]]</a>
                slots to <code>false</code>.</li>
                <li>Set <var>stream</var>'s <a>[[\QuicStreamState]]</a> slot to
                <code>closing</code>.</li>
                <li>If the <var>stream</var> has received a STREAM frame with the FIN bit set,
                set <var>stream</var>'s <a>[[\QuicStreamState]]</a> slot to <code>closed</code>.</li>
                <li>If the closing procedure has not started yet, start it by sending a RST_STREAM
                frame.</li>
              </ol>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
           <dt><dfn><code>waitForReadable</code></dfn></dt>
            <dd>
              <p><code>waitForReadable</code> waits for data to become available, or
              for the <code><a>RTCQuicStream</a></code> to be finished reading.  It
              <a>resolves</a> the promise when the data queued in the read buffer
              increases above the amount provided as an argument or when a STREAM frame
              with the FIN bit set has been received. If <code>waitForReadable</code>
              is called multiple times, multiple promises could be resolved.
              The Promise will be <a>rejected</a> with a newly created
              <code>InvalidStateError</code> if the <var>stream</var>'s
              <a>[[\Readable]]</a> slot transitions from true to false and the promise
              isn't <a>settled</a>. When the <code>waitForReadable</code> method is
              called, the <a>user agent</a> MUST run the following steps:</p>
              <ol>
                <li>Let <var>stream</var> be the <code><a>RTCQuicStream</a></code>
                on which <code>waitForReadable</code> is invoked.</li>
                <li>Let <var>p</var> be a new promise.</li>
                <li>If <var>stream</var>'s <a>[[\Readable]]</a> slot is
                <code>false</code>, <a>reject</a> <var>p</var> with a
                newly created <code>InvalidStateError</code> and abort
                these steps.</li>
                <li>Let <var>amount</var> be the first argument.</li>
                <li><a>Resolve</a> <var>p</var> with <code>undefined</code> when
                any of the following conditions are met:
                  <ol>
                    <li>The <a>[[\ReadableAmount]]</a> increases from
                    below the value of <var>amount</var> to greater than or equal
                    to it.</li>
                    <li><var>stream</var> receives a STREAM frame with the
                    FIN bit set and <a>[[\ReadableAmount]]</a> is less than
                    <var>amount</var>.</li>
                  </ol>
                </li>
              </ol>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">amount</td>
                    <td class="prmType"><code>unsigned long</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>Promise&lt;void&gt;</code>
              </div>
            </dd>
            <dt><dfn><code>waitForQueuedBelow</code></dfn></dt>
            <dd>
              <p><code>waitForQueuedBelow</code> <a>resolves</a> the promise when
              the data queued in the write buffer falls below the given threshold.
              If <code>waitForQueuedBelow</code>
              is called multiple times, multiple promises could be resolved when the
              write buffer falls below the threshold for each promise. The Promise will
              be <a>rejected</a> with a newly created <code>InvalidStateError</code> if the
              <var>stream</var>'s <a>[[\Writable]]</a> slot transitions from true to false
              and the promise isn't <a>settled</a>. When the <code>waitForQueuedBelow</code> method
              is called, the <a>user agent</a> MUST run the following steps:</p>
              <ol>
                <li>Let <var>stream</var> be the <code><a>RTCQuicStream</a></code>
                object on which <code>waitForQueuedBelow</code> was invoked.</li>
                <li>Let <var>p</var> be a new promise.</li>
                <li>If <var>stream</var>'s <a>[[\Writable]]</a> slot is
                <code>false</code>, <a>reject</a> <var>p</var> with a
                newly created <code>InvalidStateError</code> and abort
                these steps.</li>
                <li>Let <var>threshold</var> be the first argument.</li>
                <li>When <var>stream</var>'s <a>[[\QueuedAmount]]</a> slot decreases
                from above <var>threshold</var> to less than or equal to it,
                <a>resolve</a> <var>p</var> with <code>undefined</code>.</li>
              </ol>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">threshold</td>
                    <td class="prmType"><code>unsigned long</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>Promise&lt;void&gt;</code>
              </div>
            </dd>
        </dl>
      </section>
      </div>
    </section>
    <section id="rtcquicstreamstate*">
      <h2><dfn>RTCQuicStreamState</dfn> Enum</h2>
      <p>The <code>RTCQuicStreamState</code> provides information
      on the state of the QUIC stream.</p>
      <div>
        <pre class="idl">enum RTCQuicStreamState {
    "new",
    "opening",
    "open",
    "closing",
    "closed"
};</pre>
       <table data-link-for="RTCQuicStreamState" data-dfn-for="RTCQuicStreamState"
        class="simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-RTCQuicStreamState.new">new</code></dfn></td>
              <td>
                <p>The <a>user agent</a> has not yet attempted to
                establish the underlying stream transport.  This is
                the initial state of an <code><a>RTCQuicStream</a></code>
                object, corresponding to the "idle" state in
                [[QUIC-TRANSPORT]] Section 10.2.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id="idl-def-RTCQuicStreamState.opening">opening</code></dfn></td>
              <td>
                <p>The underlying QUIC stream has queued a STREAM frame for
                transmission, but has not yet received an acknowledgement.
                On transitioning to the <code>opening</code> state, the
                <a>[[\Writable]]</a> slot is set to <code>true</code>.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id="idl-def-RTCQuicStreamState.open">open</code></dfn></td>
              <td>
                <p>The underlying QUIC stream has received a STREAM, MAX_STREAM_DATA or
                STREAM_BLOCKED frame, or has sent a STREAM frame and received an acknowledgement,
                as described in [[QUIC-TRANSPORT]] Section 10.2. This is the initial state of an
                <code><a>RTCQuicStream</a></code> object dispatched as a part of an
                <code>RTCQuicStreamEvent</code>. On transitioning to the <code>open</code>
                state, the <a>[[\Readable]]</a> and <a>[[\Writable]]</a> slots are set to
                <code>true</code>.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-RTCQuicStreamState.closing">closing</code></dfn></td>
              <td>
                <p>The procedure to close down the <code><a>RTCQuicStream</a></code>
                <var>stream</var> has started.
                This can happen in multiple ways:</p>
                  <ol>
                     <li><var>stream</var> has not <a>finished reading</a> and the
                     <code>reset</code> method has been called. This causes a
                     RST_STREAM frame to be queued for transmission, the read
                     and write buffers to be cleared and <var>stream</var>'s
                     <a>[[\Readable]]</a> and <a>[[\Writable]]</a> slots to be set
                     to <code>false</code>.</li>
                     <li><var>stream</var> has not <a>finished reading</a> and the
                     <code>finish</code> method has been called. This causes a
                     STREAM frame with the FIN flag set to be queued for transmission,
                     the write buffer to be cleared and <var>stream</var>'s
                     <a>[[\Writable]]</a> slot to be set to <code>false</code>.</li>
                     <li><var>stream</var> has <a>finished reading</a>. This causes
                     <var>stream</var>'s <a>[[\Readable]]</a> slot to be set to
                     <code>false</code>.</li>                     
                  </ol>
              </td>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-RTCQuicStreamState.closed">closed</code></dfn></td>
              <td>
                <p>The <code><a>RTCQuicStream</a></code> <var>stream</var> has been
                closed or could not be established. This can happen in multiple ways:</p>
                  <ol>
                     <li>A RST_STREAM frame has been received.</li>
                     <li>A RST_STREAM frame has been sent and a STREAM frame
                     with the FIN flag set has been received.</li>
                     <li>A STREAM frame with the FIN flag set has been sent
                     and <var>stream</var> has <a>finished reading</a>.
                     </li>
                  </ol>
                <p>On transitioning to the <code>closed</code> state, <var>stream</var>'s
                <a>[[\Readable]]</a> and <a>[[\Writable]]</a> slots are set to
                <code>false</code>.</p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <figure>
      <img alt="RTCQuicStreamState transition diagram" src=
      "images/quicstream-state-revised.svg" style="width:50%">
      <figcaption>
        RTCQuicStreamState transition diagram
      </figcaption>
      </figure>
    </section>
  </section>
    <section id="privacy-security">
    <h2>Privacy and Security Considerations</h2>
    <p>This section is non-normative; it specifies no new behaviour, but
    instead summarizes information already present in other parts of the
    specification. The overall security considerations of the
    APIs and protocols used in WebRTC are described in
    [[RTCWEB-SECURITY-ARCH]].</p>
    <section>
      <h2>Impact on same origin policy</h2>
      <p>The QUIC API enables data to be communicated between
      browsers and other devices, including other browsers.</p>
      <p>This means that data can be shared between applications
      running in different browsers, or between an application running in the
      same browser and something that is not a browser.  This is an extension
      to the Web model which has had barriers against sending data
      between entities with different origins.</p>
      <p>This specification provides no user prompts or chrome indicators
      for communication; it assumes that once the Web page has been allowed to
      access data, it is free to share that data with other entities as it
      chooses. Peer-to-peer exchanges of data via QUIC can therefore
      occur without any user explicit consent or involvement.</p>
    </section>
    <section>
      <h2>Impact on local network</h2>
      <p>Since the browser is an active platform executing in a trusted network
      environment (inside the firewall), it is important to limit the damage
      that the browser can do to other elements on the local network, and it is
      important to protect data from interception, manipulation and
      modification by untrusted participants.</p>
      <p>Mitigations include:</p>
      <ul>
        <li>An UA will always request permission from the correspondent UA to
        communicate using ICE. This ensures that the UA can only send to
        partners who you have shared credentials with.</li>
        <li>An UA will always request ongoing permission to continue sending
        using ICE consent [[!RFC7675]]. This enables a receiver to withdraw
        consent to receive.</li>
        <li>An UA will always encrypt data, with strong per-session keying.</li>
        <li>An UA will always use congestion control. This ensures that QUIC
        cannot be used to flood the network.</li>
      </ul>
      <p>These measures are specified in the relevant IETF documents.</p>
    </section>
    <section>
      <h2>Confidentiality of Communications</h2>
      <p>The fact that communication is taking place cannot be hidden from
      adversaries that can observe the network, so this has to be regarded as
      public information.</p>
      <p>Since the QUIC protocol utilizes a cryptographic negotiation based on
      TLS 1.3 [[TLS13]] in order to encrypt communications, it provides confidentiality.</p>
    </section>
    <section>
      <h2>Persistent information</h2>
      <p>Utilizing the <code>generateCertificate</code> API in [[!WEBRTC]], it is possible to
      generate and store certificates that can subsequently be reused in constructing
      <code><a>RTCQuicTransport</a></code> objects.  These persistent certificates
      can therefore be used to identify a user.</p>
    </section>
  </section>
  <section class="informative">
    <h2>Event summary</h2>
    <p>The following events fire on <code><a>RTCQuicTransport</a></code> objects:</p>
    <table style="border-width:0; width:60%" border="1">
      <tbody>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Fired when...</th>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><code>error</code></td>
          <td><code><a>ErrorEvent</a></code></td>
          <td>The <code><a>RTCQuicTransport</a></code> object has encountered an error.</td>
        </tr>
        <tr>
          <td><code>statechange</code></td>
          <td><code><a>Event</a></code></td>
          <td>The <code><a>RTCQuicTransportState</a></code> changed.</td>
        </tr>
        <tr>
          <td><dfn><code>quicstream</code></dfn></td>
          <td><code><a>RTCQuicStreamEvent</a></code></td>
          <td>A new <code><a>RTCQuicStream</a></code> is dispatched to the script in
          response to the remote peer creating a QUIC stream.</td>
        </tr>
      </tbody>
    </table>
    <p>The following events fire on <code><a>RTCQuicStream</a></code> objects:</p>
    <table style="border-width:0; width:60%" border="1">
      <tbody>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Fired when...</th>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><code>statechange</code></td>
          <td><code><a>Event</a></code></td>
          <td>The <code><a>RTCQuicStreamState</a></code> changed.</td>
        </tr>
      </tbody>
    </table>
  </section>
 <section class="informative" id="examples*">
    <h2>Examples</h2>
      <pre class="example highlight">
      </pre>
 </section>
 <section id="change-log*">
    <h2>Change Log</h2>
    <p>This section will be removed before publication.</p>
 </section>
 <section class="appendix">
    <h2>Acknowledgements</h2>
    <p>The editors wish to thank the Working Group chairs and Team Contact,
    Harald Alvestrand, Stefan H&aring;kansson, Bernard Aboba and Dominique
    Haza&euml;l-Massieux, for their support. Contributions to this
    specification were provided by Robin Raymond.</p>
    <p>The <code><a>RTCQuicTransport</a></code> and <code><a>RTCQuicStream</a></code> objects
    were initially described in the <a href="https://www.w3.org/community/ortc/">W3C ORTC CG</a>,
    and have been adapted for use in this specification.</p>
 </section>
</body>
</html>
